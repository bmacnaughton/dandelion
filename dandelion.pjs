/*******************************************************************************
 * 
 * Copyright 2011 Zack Grossbart 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 ******************************************************************************/

/*
 * These are all the colors for our dandelion
 */
var seedBulbColor = '#d0aa7b';
var stemColor = '#567e37';
var wispColor = '#fff3c9';
var seedStemColor = stemColor;

var maxEdgeSeeds = 1000;
var maxCenterSeeds = 36;
//maxEdgeSeeds = 1;
//maxCenterSeeds = 0;
seedStemColor = 'black';


/**
 * This script uses a lot of random numbers to make everything
 * look more natural.  This function is just an easy way to
 * generate random numbers between two numbers. 
 *  
 * @param from the minimum number 
 * @param to the maximum number 
 */
function random(/*int*/ from, /*int*/ to) {
    return Math.floor(Math.random() * (to - from + 1) + from);
}


var seedStemLow = 10;
var seedStemHigh = 50;
seedStemLow = 20;
seedStemHigh = 30;

/**
 * This function acts like an object in paperscript.  It
 * represents each seed on the dandelion and handles drawing and
 * moving the seed.
 */
function Seed() {
    var seedStemColor = stemColor;
    var flutterLow = 4;
    var flutterHigh = 10;

    seedStemColor = 'black';

    //
    // create a seed at the specified point. the point is where the center
    // of the oval at the bottom of the seed is positioned.
    //
    // @param p the point for the center of the oval where the seed is attached
    // @param angle the angle to rotate the seed around the seed's oval
    // @param shortStem true if the seed should have a short stem
    //
    this.create = function (p, angle, stemHeight) {
        /*
        var height = 2;

        // short stem is kind of a hack used for seeds in middle of the
        // bulb
        if (!shortStem) {
            height = random(seedStemLow, seedStemHigh);
        }
        // */

        // group all the seed parts together so it can be manipulated as
        // a single unit
        var group = new Group();

        // now draw the seed. start with a small ovall at the bottom
        // where it attaches to the bulb.
        var bottom = new Path.Ellipse({
            center: p,
            radius: [2, 5],
            fillColor: seedBulbColor,
            opacity: 0.5,
        });
        group.addChild(bottom);

        // TODO move stem length logic out of seed creation. pass stem
        // length as parameter.
        /*
        if (shortStem) {
            p.y -= height;
            p.x -= 5;
        }
        // */

        // The stem of the seed is a gentle arc which pulls randomly to
        // one direction or the other.
        var stem = new Path();
        stem.strokeColor = seedStemColor;
        stem.strokeWidth = 1;
        stem.add(new Point(p.x + 2, p.y));

        var throughPoint = new Point(p.x + 4, p.y - stemHeight / 2);
        var toPoint = new Point(p.x + 3, p.y - stemHeight);
        stem.arcTo(throughPoint, toPoint);
        group.addChild(stem);
        
        /*
         * At the top of the stem are the fluttery parts that stick out of the
         * top and catch the wind.  We draw a random number of flutters between
         * four and ten.
         * 
         * Each flutter is an arc with a circle on top;
         */
        p = toPoint;
        for (var i = 0; i < random(4, 10); i++) {
            path = new Path();
            path.strokeColor = wispColor;
            path.strokeWidth = 1;
            
            var p1 = new Point(p.x, p.y);
            path.add(new Point(p1.x + 2, p1.y + 2));

            // Each flutter extends a random amount up in the air
            var y = random(1, 5);
            
            // Alternate flutters right and left to simulate dandelion
            // symmetry.
            var rand = random(1, 3);
            throughPoint = new Point(p1.x + (i & 1 ? -rand : rand), p1.y - y);
            rand = random(5, 35);
            toPoint = new Point(p1.x + (i & 1 ? -rand : rand), p1.y - 20 - y);

            path.arcTo(throughPoint, toPoint);
            group.addChild(path);

            // put a circle at the top of the flutter
            circle = new Path.Circle(toPoint, 2);
            circle.fillColor = wispColor;
            group.addChild(circle);
        }
        
        // This group contains all of the pieces of our seed so we can 
        // work with them as a unit. rotate the group around the bottom
        // of the seed.
        this.group = group;
        this.group.rotate(angle, bottom.position);
        //this.group.rotate(angle, this.group.position + [0, 15]);

        // keep track of where this seed is and what angle it's been rotated to
        //this.position = new Point(this.group.position.x, this.group.position.y + 15);
        this.angle = angle;

        // set where the seed will get blown to
        this.dest = new  Point(1800, random(-300, 1100));
        
    }
    
    /**
     * This function rotates the seed around its center by the
     * specified angle.
     * 
     * @param angle the amount of rotation for this seed
     */
    this.rotate = function(/*int*/ angle) {
        this.group.rotate(angle);
        this.angle += angle;
    }
    
    /**
     * This function rotates the seed a certain amount around the 
     * center point of our canvas.  This is what makes the seeds 
     * move across the screen in an arcing pattern that looks like 
     * they are floating. 
     */
    this.rotateMove = function(/*int*/ angle) {
        // do accurate off screen check.
        if (this.group.bounds.topLeft.x > view.bounds.width ||
            this.group.bounds.bottomLeft.y < 0 ||
            this.group.bounds.topLeft.y > view.bounds.height) {
            this.isOffScreen = true;
            return;
        }

        // it's on screen so move it and rotate it so it looks like it's
        // blowing in the breeze
        var vector = this.dest - this.group.position;
        this.group.position += vector / 150;
        this.rotate(angle);
    }
    
    /**
     * This function tells us if the seed is off the screen since
     * there's no reason to keep animating the seed once it's off
     * the screen.
     */
    this.isOffscreen = function() {
        return this.isOffScreen;
    }
}

//var seeds = [];
var seedCount = 0;
var started = false;

var seeds = {attached: [], floating: [], offscreen: []};

/**
 * This function initializes our script.
 */
function init() {
    
    // Save the paperscope object so it can be used later for
    // the in-place code editing
    // TODO BAM isn't this just paper.PaperScope? and what if there
    // are more than one?
    codeMgr.scope = paper;
    /*
    PaperScope.each(function(scope) {
        if (scope.project) {
            codeMgr.scope = scope;
        }
    });
    // */
    
    $('#edit').click(function(evt) {
        started = false;
    });
    
    /*
     * Now we draw the stem of our dandelion with a thick
     * green arcing line.
     */
    var path = new Path();
    path.strokeColor = stemColor;
    path.strokeWidth = 5;
    
    var firstPoint = new Point(0, 550);
    path.add(firstPoint);
    
    var throughPoint = new Point(75, 400);
    var toPoint = new Point(100, 250);
    path.arcTo(throughPoint, toPoint);
    
    /*
     * The bulb of the flower is a green circle.
     */
    var bulb = new Path.Circle(toPoint, 10);
    bulb.fillColor = stemColor;
    
    var angle = 360 / bulb.length;
    var normal = bulb.getNormalAt(0);
    //console.log(normal, normal.angle);
    
    /*
     * The first set of seeds go around the perimeter of the bulb.
     * They rotate based on their location in the circle so they
     * always point out from the bulb.
     */
    var nSeeds = Math.min(bulb.length, maxEdgeSeeds);

    for (var i = 0; i < nSeeds; i++) {
        var seed = new Seed();
        var height = random(seedStemLow, seedStemHigh);
        //seed.create(bulb.getPointAt(i), i * angle);
        seed.create(bulb.getPointAt(i), normal.angle/2 + (i * angle), height);
        seeds.attached.push(seed);
    }

    /*
     * Then we add another set of seeds to the middle of the flower
     * so it covers the green in the middle and makes the dandelion
     * look extra fluffy.
     */
    for (var i = 0; i < maxCenterSeeds; i++) {
        var seed = new Seed();
        var point = new Point(toPoint.x + random(-3, 3),
                              toPoint.y + random(-3, 3));
        //seed.create(new Point(point), random(0, 360), 2);
        seed.create(toPoint, random(0, 360), 2);
        seeds.attached.push(seed);
    }
    
    /*
     * We start the seeds blowing after a delay.
     */
    setTimeout(start, 1000);
}

/**
 * This function starts the animation.  We use an interval timer to
 * launch each seed.
 * TODO BAM: could more randomly choose when to launch each seed
 */
function start() {
    started = true;
    
    var id = setInterval(function() {
        // don't launch seeds when onFrame isn't running
        if (!started || !document.hasFocus()) {
            return;
        }
        // launch a seed if any remain attached
        if (seeds.attached.length) {
            seeds.floating.push(seeds.attached.shift());
            return;
        }
        // no seeds remain attached
        clearInterval(id);
    }, 500);
}

/**
 * This function helps us with debugging.  We can stop and start
 * the animation whenever the user clicks the mouse.
 */
function onMouseUp(event) {
    started = !started;
}

/**
 * This function is called with each frame of the animation.
 */
function onFrame(event) {
    if (started && seeds.floating.length) {
        var i = 0;

        while (i < seeds.floating.length) {
            // if the seed is offscreen remove it from the floating array
            // and add it to the offscreen seeds. don't increment the index
            // because the length is now one shorter than it used to be and
            // the index refers to the item past the one just removed.
            if (seeds.floating[i].isOffScreen) {
                seeds.offscreen.push(seeds.floating.splice(i, 1));
                continue;
            }
            // this seed stays in the floating seeds array so rotate it then
            // increment the index to check on the next seed.
            seeds.floating[i].rotateMove(2, 4);
            i += 1;
        }
    }
}

init();
